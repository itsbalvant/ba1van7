<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unlimited Mint: The Chair Function That Could Break a Stablecoin — Balvant Chavda</title>
    <!-- Preload critical CSS -->
    <link rel="preload" href="../css/style.css" as="style">
    <link rel="stylesheet" href="../css/style.css">
    <!-- Font Awesome loaded with defer to not block rendering -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <!-- Preconnect to Google Fonts to speed up font loading -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&display=swap" media="print" onload="this.media='all'">
    <!-- Add meta description for SEO -->
    <meta name="description" content="Analysis of a critical vulnerability in a DeFi protocol that allowed unlimited token minting, potentially leading to protocol insolvency.">
    <!-- Cache control headers -->
    <meta http-equiv="Cache-Control" content="max-age=86400">
    <style>
        /* Blog post specific styles */
        .post-header {
            height: 40vh;
            display: flex;
            align-items: center;
            background: linear-gradient(to right, rgba(16, 16, 16, 0.95), rgba(16, 16, 16, 0.95));
            margin-bottom: 2rem;
        }
        
        .post-meta {
            margin-bottom: 2rem;
            color: var(--accent-color);
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .post-category {
            display: inline-block;
            margin-right: 1rem;
            color: var(--secondary-color);
        }
        
        .post-date {
            display: inline-block;
        }
        
        .post-content {
            max-width: 1100px;
            margin: 0 auto;
            padding-bottom: 4rem;
        }

        .post-content h1 {
            font-size: 3rem;
            margin-bottom: 1.5rem;
            font-weight: 800;
            letter-spacing: -1px;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .post-content p {
            margin-bottom: 1.5rem;
            font-size: 1.05rem;
            line-height: 1.7;
        }
        
        .post-content h2 {
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            font-size: 2rem;
            letter-spacing: -0.5px;
        }
        
        .post-content h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-size: 1.4rem;
            letter-spacing: -0.5px;
            color: var(--secondary-color);
        }
        
        .post-content ul, .post-content ol {
            margin-bottom: 1.5rem;
            padding-left: 1.5rem;
        }
        
        .post-content li {
            margin-bottom: 0.8rem;
            position: relative;
        }

        .post-content ul li::before {
            content: "▹";
            position: absolute;
            left: -1.3em;
            color: var(--secondary-color);
            font-size: 1.2em;
        }
        
        .post-content code {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            color: var(--accent-color);
        }
        
        .code-block {
            background-color: #1a1a1a;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            border-left: 4px solid var(--secondary-color);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }
        
        .post-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .back-to-blog {
            display: inline-flex;
            align-items: center;
            color: var(--secondary-color);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: var(--transition);
        }
        
        .back-to-blog:hover {
            color: var(--accent-color);
            transform: translateX(-5px);
        }
        
        .back-to-blog i {
            margin-right: 0.5rem;
        }

        .blog-image-container {
            margin: 2rem 0;
            text-align: center;
        }

        .blog-image {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
        }

        .image-caption {
            margin-top: 1rem;
            color: var(--text-color);
            font-size: 0.9rem;
            font-style: italic;
        }

        .severity-tag {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            border-radius: 50px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            background-color: rgba(244, 67, 54, 0.2);
            color: #f44336;
            margin-right: 1rem;
        }

        .reward-tag {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            border-radius: 50px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            background-color: rgba(0, 255, 163, 0.1);
            color: var(--secondary-color);
        }

        /* Mobile styles */
        @media (max-width: 576px) {
            .post-content h1 {
                font-size: 2rem;
                letter-spacing: -0.5px;
            }
            
            .post-content h2 {
                font-size: 1.6rem;
            }
            
            .post-content h3 {
                font-size: 1.2rem;
            }
            
            .post-content p {
                font-size: 1rem;
                line-height: 1.6;
            }
            
            .code-block {
                padding: 1rem;
                font-size: 0.8em;
                overflow-x: auto;
                white-space: pre-wrap;
                word-wrap: break-word;
            }
            
            .warning-note, .info-note {
                padding: 0.8rem 1rem;
                font-size: 0.9rem;
            }
            
            .severity-tag, .reward-tag {
                padding: 0.2rem 0.6rem;
                font-size: 0.7rem;
                margin-top: 0.5rem;
                display: inline-block;
            }
        }
    </style>
</head>
<body>
    <!-- Header with Avatar -->
    <header>
        <div class="container">
            <a href="../index.html" class="logo">
                <span class="logo-text">Balvant<span class="domain">.IN</span></span>
            </a>
            <nav aria-label="Main navigation">
                <ul>
                    <li><a href="../index.html#blog"><span><i class="fas fa-blog" aria-hidden="true"></i> Blog</span></a></li>
                    <li><a href="../books.html"><span><i class="fas fa-book" aria-hidden="true"></i> Books</span></a></li>
                    <li><a href="../index.html#hall-of-fame"><span><i class="fas fa-trophy" aria-hidden="true"></i> Hall of Fame</span></a></li>
                    <!-- <li><a href="../projects.html"><span><i class="fas fa-code-branch" aria-hidden="true"></i> Projects</span></a></li> -->
                    <li><a href="../contact.html" class="contact-btn"><span><i class="fas fa-paper-plane" aria-hidden="true"></i> Contact Me</span></a></li>
                </ul>
            </nav>
            <div class="menu-toggle">
                <i class="fas fa-bars"></i>
            </div>
        </div>
    </header>
    
    <!-- Add space for fixed header -->
    <div style="height: 80px;" class="header-spacer"></div>

    <!-- Post Content -->
    <section class="post-content">
        <div class="container">
            <h1>Unlimited Mint: The Chair Function That Could Break a Stablecoin</h1>
            <div class="post-meta">
                <span class="post-category">Web3 Security</span>
                <span class="post-date">Published on March 13, 2025</span>
            </div>
            
            <div style="margin-bottom: 2rem; display: flex; flex-wrap: wrap; gap: 10px;">
                <span class="severity-tag">Severity: High</span>
                <span class="reward-tag">Reward: REDACTED</span>
            </div>
            
            <p>DeFi protocols introduce novel financial primitives, but also unique security challenges. In this writeup, I'll share my discovery of a critical vulnerability in a federated token contract that allowed unlimited minting of the underlying token, potentially leading to protocol insolvency and significant user losses.</p>
            
            <h2>Vulnerability Details</h2>
            
            <p>The expansion function in the Anchor Fed contract (Fed.sol) at a major DeFi protocol allowed the chair role to mint an unlimited amount of the underlying token (stablecoin) without an upper bound or a timelock/cooldown mechanism. This unrestricted minting capability posed a significant risk of supply inflation, potential peg destabilization, and economic manipulation if the chair role was compromised or misused.</p>
            
            <h3>Affected Code</h3>
            
            <p>The vulnerability resided in the expansion function of the Fed.sol contract. Here's the relevant code snippet:</p>
            
            <div class="code-block">
                <pre>function expansion(uint amount) public {
    require(msg.sender == chair, "ONLY CHAIR");
    underlying.mint(address(this), amount);
    require(ctoken.mint(amount) == 0, 'Supplying failed');
    supply = supply.add(amount);
    emit Expansion(amount);
}</pre>
            </div>
            
            <h3>Impact Details</h3>
            
            <p>This vulnerability had severe implications for the Anchor Fed contract:</p>
            
            <ul>
                <li><strong>Economic Manipulation:</strong> The chair could inflate the stablecoin supply arbitrarily, potentially breaking its peg and undermining the protocol's stability.</li>
                <li><strong>Trust Risk:</strong> If the chair's private key was compromised or the role was abused, an attacker could mint unlimited tokens, draining value from the ecosystem or manipulating external protocols (e.g., Compound via ctoken).</li>
                <li><strong>Systemic Risk:</strong> Over-supplying the stablecoin could disrupt lending markets or lead to loss of confidence in the protocol's products.</li>
            </ul>
            
            <p>I rated this vulnerability as High severity due to the potential for significant economic damage and the reliance on a single point of failure (chair) without additional safeguards.</p>
            
            <h2>Key Issues</h2>
            
            <h3>1. No Upper Bound on Minting Amount</h3>
            
            <p>The <code>amount</code> parameter was a <code>uint</code> with no maximum limit enforced. The chair could mint any value up to 2^256 - 1, which is practically unlimited. This allowed for arbitrary inflation of the token supply.</p>
            
            <h3>2. No Timelock or Cooldown Period</h3>
            
            <p>The function could be called repeatedly in the same transaction or across multiple transactions without delay. There was no mechanism to prevent rapid, successive minting events.</p>
            
            <h3>3. Sole Reliance on chair Access Control</h3>
            
            <p>Only the chair could call this function, but there were no additional checks (e.g., multi-sig, governance approval, or timelock) to mitigate misuse or compromise of the chair role.</p>
            
            <h2>Proof of Concept</h2>
            
            <p>I developed a PoC to demonstrate the vulnerability. The test simulated the chair minting large amounts of tokens repeatedly, confirming the lack of restrictions.</p>
            
            <h3>Solidity Code</h3>
            
            <div class="code-block">
                <pre>// SPDX-License-Identifier: MIT
pragma solidity ^0.5.16;

// Mock contracts needed for testing
contract ERC20Mock {
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    uint256 public totalSupply;
    
    function mint(address to, uint256 amount) public {
        balanceOf[to] += amount;
        totalSupply += amount;
    }
    
    function burn(uint256 amount) public {
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
    }
    
    function approve(address spender, uint256 amount) public returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract CErc20Mock {
    ERC20Mock public underlyingToken;
    
    constructor(address underlying_) public {
        underlyingToken = ERC20Mock(underlying_);
    }
    
    function mint(uint256 amount) external returns (uint) {
        return 0;
    }
    
    function underlying() external view returns (address) {
        return address(underlyingToken);
    }
    
    function redeemUnderlying(uint256 amount) external returns (uint) {
        return 0;
    }
}

contract Fed {
    using SafeMath for uint;
    
    CErc20Mock public ctoken;
    ERC20Mock public underlying;
    address public chair;
    address public gov;
    uint public supply;

    event Expansion(uint amount);
    event Contraction(uint amount);

    constructor(CErc20Mock ctoken_, address gov_) public {
        ctoken = ctoken_;
        underlying = ERC20Mock(ctoken_.underlying());
        underlying.approve(address(ctoken), uint(-1));
        chair = msg.sender;
        gov = gov_;
    }

    function expansion(uint amount) public {
        require(msg.sender == chair, "ONLY CHAIR");
        underlying.mint(address(this), amount);
        require(ctoken.mint(amount) == 0, 'Supplying failed');
        supply = supply.add(amount);
        emit Expansion(amount);
    }
}

// POC Contract
contract FedExploitTest {
    Fed public fed;
    CErc20Mock public ctoken;
    ERC20Mock public underlying;
    
    event LogBalance(uint256 balance);
    event LogSupply(uint256 supply);
    
    constructor() public {
        // Deploy mock tokens
        underlying = new ERC20Mock();
        ctoken = new CErc20Mock(address(underlying));
        
        // Deploy Fed with this contract as gov
        fed = new Fed(ctoken, address(this));
    }
    
    function runExploit() public {
        // Initial state
        emit LogSupply(underlying.totalSupply());
        
        // Exploit 1: Mint a large amount multiple times to show no restrictions
        for(uint i = 0; i < 5; i++) {
            fed.expansion(1000000 * 10**18); // 1 million tokens each time
            emit LogSupply(underlying.totalSupply());
        }
    }
    
    // Additional function to show minting can be done repeatedly
    function mintMore(uint256 amount) public {
        fed.expansion(amount);
        emit LogSupply(underlying.totalSupply());
    }
}</pre>
            </div>
            
            <h3>Exploitation Steps</h3>
            
            <ol>
                <li>Deploy the FedExploitTest contract</li>
                <li>Call runExploit() to mint 5 million tokens (5 iterations of 1M * 10^18)</li>
                <li>Call mintMore(1000000000000000000000000) multiple times to mint additional 1M tokens without restrictions</li>
            </ol>
            
            <h3>Results</h3>
            
            <p>From the initial supply of 0, I was able to mint unlimited tokens in rapid succession:</p>
            <ul>
                <li>After 1st mint: 1,000,000 tokens</li>
                <li>After 2nd mint: 2,000,000 tokens</li>
                <li>After 3rd mint: 3,000,000 tokens</li>
                <li>After 4th mint: 4,000,000 tokens</li>
                <li>After 5th mint: 5,000,000 tokens</li>
                <li>After additional calls: 8,000,000 tokens total</li>
            </ul>
            
            <p>This demonstrated that the chair could mint any amount of tokens without limits or delays, potentially destabilizing the entire protocol.</p>
            
            <h2>Observations and Analysis</h2>
            
            <p>Through my analysis, I observed several key issues with the Fed contract's design:</p>
            
            <ul>
                <li>The chair (deployer) could mint tokens with no limits or delays, allowing for arbitrary inflation</li>
                <li>Additional mints succeeded immediately in separate transactions, confirming no cooldown</li>
                <li>Even if the chair was intended to be a trusted entity (e.g., a multi-sig), the lack of on-chain limits remained a concern</li>
                <li>The vulnerability could affect the entire ecosystem due to the token's role in the protocol</li>
            </ul>
            
            <h2>Recommended Mitigation Strategies</h2>
            
            <p>To address this vulnerability, I recommended several mitigation strategies:</p>
            
            <h3>1. Implement Maximum Mint Limits</h3>
            
            <div class="code-block">
                <pre>// Add protocol-wide configuration
uint256 public maxMintAmount;

function expansion(uint amount) public {
    require(msg.sender == chair, "ONLY CHAIR");
    require(amount <= maxMintAmount, "AMOUNT EXCEEDS MAXIMUM");
    // ... rest of the function
}</pre>
            </div>
            
            <h3>2. Add Timelock Mechanism</h3>
            
            <div class="code-block">
                <pre>// Add cooldown period
uint256 public lastMintTimestamp;
uint256 public constant MINT_COOLDOWN = 1 days;

function expansion(uint amount) public {
    require(msg.sender == chair, "ONLY CHAIR");
    require(block.timestamp >= lastMintTimestamp + MINT_COOLDOWN, "COOLDOWN ACTIVE");
    
    // ... rest of the function
    
    lastMintTimestamp = block.timestamp;
}</pre>
            </div>
            
            <h3>3. Implement Multi-signature Requirements</h3>
            
            <p>Replace the single chair role with a multi-signature mechanism requiring approval from multiple authorized entities, significantly reducing the risk of compromise or misuse.</p>
            
            <h2>The Vendor's Response</h2>
            
            <p>After reporting this issue through the protocol's bug bounty program, the security team determined that the vulnerability was out of scope for a reward. Their rationale was that attacks requiring access to privileged addresses (including governance and strategist contracts) without additional modifications to the privileges were excluded from the bounty program.</p>
            
            <p>While I understand their perspective based on the specific terms of the bug bounty program, I maintain that unlimited minting with no cooldown could destabilize the token's peg even if the chair is a multi-sig. Past DeFi exploits have shown that privileged roles can be compromised, and on-chain limits would provide a valuable safety net.</p>
            
            <h2>Lessons Learned</h2>
            
            <p>This vulnerability highlights several important principles for secure DeFi development:</p>
            
            <ul>
                <li><strong>Defense in Depth:</strong> Even trusted roles should have on-chain constraints to minimize damage if compromised</li>
                <li><strong>Economic Safety Guards:</strong> DeFi protocols should implement mechanisms to prevent economic attacks, such as rate limits and maximum caps</li>
                <li><strong>Trust Minimization:</strong> While administrative privileges are often necessary, their power should be constrained through technical measures</li>
                <li><strong>Multi-layer Security:</strong> Combine access controls with parameter bounds, timelocks, and monitoring systems</li>
            </ul>
            
            <h2>Conclusion</h2>
            
            <p>Despite not qualifying for a bounty under the program's specific terms, disclosing this vulnerability was still valuable for the wider security community. It demonstrates how even protocol-level controls and privileged operations should incorporate safeguards against potential abuse or compromise.</p>
            
            <p>The DeFi ecosystem continues to evolve, and security must evolve with it. By discussing these issues openly, we contribute to a more secure Web3 environment that can better protect user funds and protocol stability.</p>
            
            <div class="post-nav">
                <a href="../index.html#blog" class="back-to-blog"><i class="fas fa-arrow-left"></i> Back to Blog</a>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 Balvant Chavda. All rights reserved.</p>
            <p></p>
        </div>
    </footer>

    <script src="../js/main.js" defer></script>
</body>
</html> 